
%module{ZeroMQ};

// catch the error_t exceptions with a helpful message
%exception{ZMQException}{zmq::error_t}{stdmessage};

%name{ZeroMQ::Context}
class context_t
  %catch{ZMQException}
{
  %name{new} context_t(int io_threads);
  ~context_t();
};


%name{ZeroMQ::Socket}
class socket_t
  %catch{ZMQException}
{
  %name{new} socket_t(context_t& context, int type);
  ~socket_t();

  //void socket_t::getsockopt(int option_name, void *option_value, size_t *option_len)
  //void socket_t::setsockopt(int option_name, const void *option_value, size_t option_len)

  void bind(char* endpoint);
  void connect(char* endpoint);
  bool send(message_t& msg, int flags = 0);

  //bool recv(message_t* msg, int flags = 0);
  // FIXME needs exception handling...
  {%

void
socket_t::recv(flags = 0)
    int flags;
  PPCODE:
    message_t* rv = new message_t();
    if (!THIS->recv(rv, flags)) {
      delete rv;
      XPUSHs(&PL_sv_undef);
    }
    else {
      XPUSHmortal;
      sv_setref_pv(ST(0), "ZeroMQ::Message", (void*)rv);
    }

  %}
};


%name{ZeroMQ::Message}
class message_t
  %catch{ZMQException}
{
  %name{new} message_t(char* data, size_t %length{data})
    %code{%
      /* Note: we need to copy data and provide a cleanup function */
      RETVAL = new zmq::message_t(data, length(data), NULL); 
    %};
  //%name{new} message_t();
  //%name{new} message_t(size_t size_);
  //%name{new} message_t(MsgData* data, size_t size_, free_fn *ffn_, void *hint_ = NULL);
  ~message_t();

  size_t size();
  
  //MsgData* data();
  char* data()
    %code{% RETVAL = (char*)THIS->data(); %};
};


